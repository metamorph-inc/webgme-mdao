/*globals define, WebGMEGlobal*/
/*jshint browser: true*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Wed Jan 03 2018 13:04:07 GMT-0600 (Central Standard Time).
 */

import React from 'react';
import ReactDOM from 'react-dom';

define(['css!../../widgets/Dataflow/styles/DataflowWidget.css'], function () {
    'use strict';


    class Component extends React.Component {
         render() {
                  var _props = this.props,
                      name = _props.name,
                      top = _props.top,
                      left = _props.left;


                  return <div className='Component' style={{ top: top + 'px', left: left + 'px' }} >
                      {name}</div>
              }
          }


      class App extends React.Component {
          constructor() {
              super();
              this.state = {
                  components: [
                      // { id: '/a/b/c', top: 100, left: 400, name: 'tst'}
                  ]
              };
          }

          render() {
                  var components = this.state.components;

                  return (<div>
                      { components.map(function (c) {
                          return <Component key={c.id} top={c.top} left={c.left} name={c.name} />;
                      }) }
                  </div>);
              }
          }

    var DataflowWidget,
        WIDGET_CLASS = 'dataflow';

    DataflowWidget = function DataflowWidget(logger, container) {
        this._logger = logger.fork('Widget');

        this._el = container;

        this.nodes = {};
        this._initialize();

        this.components = [];
        this.connections = {};
        this.newConnections = [];
        this._logger.debug('ctor finished');
    };

    DataflowWidget.prototype._initialize = function () {
        var width = this._el.width(),
            height = this._el.height(),
            self = this;

        // set widget class
        this._el.addClass(WIDGET_CLASS);

        this.app = ReactDOM.render(<App/>, this._el.get(0));

        // Create a dummy header
        // this._el.append('<h3>Dataflow Events:</h3>');

        // Registering to events can be done with jQuery (as normal)
        this._el.on('dblclick', function (event) {
            event.stopPropagation();
            event.preventDefault();
            self.onBackgroundDblClick();
        });
    };

    DataflowWidget.prototype.onWidgetContainerResize = function (width, height) {
        this._logger.debug('Widget is resizing...');
    };

    // Adding/Removing/Updating items
    DataflowWidget.prototype.addNode = function (desc) {
        this.nodes[desc.id] = desc;

        if (desc && desc.type === 'Component') {
            this.components.push(desc);
        } else if (desc && desc.type === 'Dataflow') {
            this.newConnections.push(desc);
        }
    };

    function getParentId(id) {
        return id.substr(0, id.lastIndexOf('/'));
    };

    function getConnectionsKey(connection) {
        var strip = getParentId;
        return strip(connection.srcId) + '__' + strip(connection.dstId);
    };

    DataflowWidget.prototype.territoryComplete = function () {
        var counter = 0;
        this.components.sort((a, b) => {
          if (a.name < b.name) {
            return -1;
          }
          if (a.name > b.name) {
            return 1;
          }
          return 0;
        });
        this.components.forEach(component => {
          component.top = 80 + counter * 100;
          component.left = 80 + counter * 100;
          counter++;
        });

        var newConnections = this.newConnections;
        this.newConnections = [];
        newConnections.forEach(this.updateConnection.bind(this));

        Object.getOwnPropertyNames(this.nodes).forEach(nodesKey => {
          var desc = this.nodes[nodesKey];
          if (desc.type === "Dataflow") {
            // FIXME update only connections whose endpoints changed
            this.updateConnection(desc);
          }
        });

        Object.getOwnPropertyNames(this.connections).forEach(connectionsKey => {
            var connection = this.connections[connectionsKey];
            var desc = connection.valueflows[0];
            var srcRect = this.nodes[getParentId(desc.srcId)];
            var dstRect = this.nodes[getParentId(desc.dstId)];
            if (!srcRect || !dstRect) {
              return;
            }
            if (srcRect.top < dstRect.top) {
                connection.element.classList.add('Dataflow_backward');
                connection.element.classList.remove('Dataflow_forward');
                connection.element.style.top = srcRect.top + 62 + 'px';
                connection.element.style.left = srcRect.left + 50 + 'px';
                connection.element.style.width = dstRect.left - srcRect.left - 50 + 'px';
                connection.element.style.height = dstRect.top - srcRect.top - 30 + 'px';
            } else {
                connection.element.classList.add('Dataflow_forward');
                connection.element.classList.remove('Dataflow_backward');
                connection.element.style.top = dstRect.top + 50 + 'px';
                connection.element.style.left = dstRect.left + 100 + 'px';
                connection.element.style.width = srcRect.left - dstRect.left - 50 + 'px';
                connection.element.style.height = srcRect.top - dstRect.top - 50 + 'px';
            }
          });
          this.app.setState({ components: this.components });
    };

    DataflowWidget.prototype.removeNode = function (gmeId) {
        var desc = this.nodes[gmeId];
        // this._el.append('<div>Removing node "' + desc.name + '"</div>');
        if (desc.connection) {
            var index = desc.connection.valueflows.indexOf(desc);
            desc.connection.valueflows.splice(index, 1);
            if (desc.connection.valueflows.length === 0) {
                desc.connection.element.remove();
                delete this.connections[desc.connection.id];
            }
        }
        var componentIndex = this.components.indexOf(desc);
        if (componentIndex !== -1) {
          this.components.splice(componentIndex, 1);

        }
        delete this.nodes[gmeId];
    };

    DataflowWidget.prototype.updateConnection = function (desc) {
      if (desc.connection && (!desc.srcId || !desc.dstId)) {
        var index = desc.connection.valueflows.indexOf(desc);
        if (index === -1) {
          return;
        }
        desc.connection.valueflows.splice(index, 1);
        if (desc.connection.valueflows.length === 0) {
            desc.connection.element.remove();
            delete this.connections[desc.connection.id];
        }
        delete desc.connection;
      }
      if (!desc.connection && (desc.srcId && desc.dstId)) {
        var connection = this.connections[getConnectionsKey(desc)];
        if (connection === undefined) {
            connection = this.connections[getConnectionsKey(desc)] = {id: getConnectionsKey(desc), valueflows: []};
            connection.element = document.createElement('div');

            connection.element.classList.add(desc.type);
            this._el.append(connection.element);
        }
        this.nodes[desc.id].connection = connection;
        connection.valueflows.push(desc);
        if (connection.valueflows.length > 5) throw Error();
      }
    }

    // copy undefined values too (unlike JQuery)
    function extend(dst, src) {
      Object.getOwnPropertyNames(src).forEach(key => {
        dst[key] = src[key];
      });
    };

    DataflowWidget.prototype.updateNode = function (desc) {
        if (desc) {
            this._logger.debug('Updating node:', desc);
            extend(this.nodes[desc.id], desc);
            if (desc.type === "Dataflow") {
              console.log(JSON.stringify(desc, (k, v) => { return  v === undefined ? null : v; }));
              this.updateConnection(this.nodes[desc.id]);
            }
            // this._el.append('<div>Updating node "' + desc.name + '"</div>');
        }
    };

    /* * * * * * * * Visualizer event handlers * * * * * * * */

    DataflowWidget.prototype.onNodeClick = function (/*id*/) {
        // This currently changes the active node to the given id and
        // this is overridden in the controller.
    };

    DataflowWidget.prototype.onBackgroundDblClick = function () {
        // this._el.append('<div>Background was double-clicked!!</div>');
    };

    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    DataflowWidget.prototype.destroy = function () {
    };

    DataflowWidget.prototype.onActivate = function () {
        this._logger.debug('DataflowWidget has been activated');
    };

    DataflowWidget.prototype.onDeactivate = function () {
        this._logger.debug('DataflowWidget has been deactivated');
    };

    return DataflowWidget;
});
