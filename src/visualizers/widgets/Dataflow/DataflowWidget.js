/*globals define, WebGMEGlobal*/
/* jshint browser: true */

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Wed Jan 03 2018 13:04:07 GMT-0600 (Central Standard Time).
 */

import React from 'react';
import ReactDOM from 'react-dom';
import joint from 'jointjs/index';

define(['css!../../widgets/Dataflow/styles/DataflowWidget.css'], function() {
    'use strict';

    class Component extends React.Component {
        constructor() {
            super();
            this.handleClick = this.handleClick.bind(this);
        }

        handleClick() {
            this.props.dispatchEvent('inspect', {
                id: this.props.id,
                type: 'Component'
            });
        }

        render() {
            var {
                name,
                top,
                left
            } = this.props;

            return <div className='Component' style={{
                    top: top + 'px',
                    left: left + 'px',
                    zIndex: 2
                }} onClick={this.handleClick}>
                {name}</div>
        }
    }

    class Connection extends React.Component {
        constructor() {
            super();
            this.handleClick = this.handleClick.bind(this);
        }

        handleClick() {
            this.props.dispatchEvent('inspect', {
                id: this.props.id,
                type: 'Connection'
            });
        }

        render() {
            var {
                points
            } = this.props;
            return <polyline xmlns="http://www.w3.org/2000/svg" points={points} markerEnd="url(#triangle)" stroke="black" strokeWidth="2" fill="none" onClick={this.handleClick}/>
        }
    }

    class InspectorConnection extends React.Component {
        render() {
            const {
                id,
                nodes,
                connections,
            } = this.props;
            const valueflows = connections[id].valueflows;
            return (<div>{ (valueflows || []).map(vf => {
                var srcPort = nodes[vf.srcId];
                var dstPort = nodes[vf.dstId];
                var src = srcPort ? nodes[srcPort.parentId] : undefined;
                var dst = dstPort ? nodes[dstPort.parentId] : undefined;
                return <div key={vf.id}>{src.name}.{srcPort.name} {dst.name}.{dstPort.name}</div>; })
            }</div>);
        }
    }

    class InspectorComponent extends React.Component {
        render() {
            const {
                nodes,
                id
            } = this.props;
            const name = nodes[id].name;
            return <div>{name}</div>;
        }
    }

    class Inspector extends React.Component {
        render() {
            var {
                type,
            } = this.props;
            const props = this.props;
            switch (type) {
                case 'Connection':
                    return (<InspectorConnection {...props}/>)
                case 'Component':
                    return (<InspectorComponent {...props}/>);
                default:
                    return <div/>;
            }
        }
    }

    class App extends React.Component {
        constructor() {
            super();
            this.state = {
                components: [
                    // { id: '/a/b/c', top: 100, left: 400, name: 'tst'}
                ],
                dispatchEvent: () => {},
                inspectorHeight: 100,
                inspector: {},
                nodes: {},
                connections: {}
            };

            this.graph = new joint.dia.Graph();
            this.cells = [];
        }

        componentDidMount() {
            const paper = new joint.dia.Paper({
                el: ReactDOM.findDOMNode(this.refs.ggg),
                width: 800,
                height: 600,
                gridSize: 1,
                model: this.graph
            });
        }

        render() {
            const {
                nodes,
                components,
                connections,
                dispatchEvent,
                width,
                height,
                inspectorHeight,
                inspector
            } = this.state;

            const graph = this.graph;

            const componentsHeight = components.map(c => {
                return c.top
            }).reduce((a, b) => {
                return Math.max(a, b)
            }, 0);

            var comp_to_cell = {};

            components.map(c => {
                var textColor = textColor || "#000";

                var cell = new joint.shapes.org.Member({
                    position: {
                        x: c.top,
                        y: c.left
                    },
                    attrs: {
                        '.card': {
                            stroke: 'none',
                            fill: '#30d0c6'
                        },
                        '.rank': {
                            text: c.type,
                            fill: textColor,
                            'word-spacing': '-5px',
                            'letter-spacing': 0
                        },
                        '.name': {
                            text: c.name,
                            fill: textColor,
                            'font-size': 13,
                            'font-family': 'Arial'
                        }
                    }
                });
                graph.addCell(cell);

                comp_to_cell[c] = cell;
            });

            connections.map(conn => {
                // Who is the source? Who is the dest?
                var conn_points = conn.id.split('__');

                var id_src = conn_points[0],
                    comp_src = 
                    id_dst = conn_points[1];

                console.log('hey');
            });

            // <div style={{width: '100%', height: components.map(c => { return c.top }).reduce((a, b) => { return Math.max(a,b) }, 0) + 200 + 'px' }}>
            // <div style={{width: '100%', height: 'calc(100% - 3em)'}}>
            return (<div style={{
                    width,
                    height
                }}>

                <div style={{
                        width: '100%',
                        height: `calc(100% - ${inspectorHeight}px)`,
                        overflow: 'auto'
                    }}><div ref="ggg"></div>
                </div>
                <div style={{
                        width: '100%',
                        height: inspectorHeight + 'px',
                        top: `calc(100% - ${inspectorHeight}px)`,
                        position: 'absolute',
                        backgroundColor: 'lightgrey'
                    }}><Inspector id={inspector.id} type={inspector.type} components={components} connections={connections} nodes={nodes}/></div>
            </div>);
        }
    }

    var DataflowWidget,
        WIDGET_CLASS = 'dataflow';

    DataflowWidget = function DataflowWidget(logger, container) {
        this._logger = logger.fork('Widget');

        this._el = container;

        this.nodes = {};
        this._initialize();

        this.components = [];
        this.connections = {};
        this.newConnections = [];
        this.dispatchEvent = this.dispatchEvent.bind(this);
        this._logger.debug('ctor finished');
    };

    DataflowWidget.prototype._initialize = function() {
        // set widget class
        this._el.addClass(WIDGET_CLASS);

        this.app = ReactDOM.render(<App/>, this._el.get(0));

        // Create a dummy header
        // this._el.append('<h3>Dataflow Events:</h3>');

        // Registering to events can be done with jQuery (as normal)
        /*this._el.on('dblclick', event => {
            event.stopPropagation();
            event.preventDefault();
            this.onBackgroundDblClick();
        }); */
    };

    DataflowWidget.prototype.onWidgetContainerResize = function(width, height) {
        this._logger.debug('Widget is resizing...');

        var state = this.app.state;
        state.width = width;
        state.height = height;
        this.app.setState(state);
    };

    DataflowWidget.prototype.render = function() {};

    // Adding/Removing/Updating items
    DataflowWidget.prototype.addNode = function(desc) {
        this.nodes[desc.id] = desc;

        if (desc && desc.type === 'Component') {
            this.components.push(desc);
        } else if (desc && desc.type === 'Dataflow') {
            this.newConnections.push(desc);
        }
    };

    function getParentId(id) {
        return id.substr(0, id.lastIndexOf('/'));
    };

    function getConnectionsKey(connection) {
        var strip = getParentId;
        return strip(connection.srcId) + '__' + strip(connection.dstId);
    };

    DataflowWidget.prototype.territoryComplete = function() {
        var counter = 0;
        this.components.sort((a, b) => {
            if (a.name < b.name) {
                return -1;
            }
            if (a.name > b.name) {
                return 1;
            }
            return 0;
        });
        this.components.forEach(component => {
            component.top = 80 + counter * 100;
            component.left = 80 + counter * 100;
            counter++;
        });

        var newConnections = this.newConnections;
        this.newConnections = [];
        newConnections.forEach(this.updateConnection.bind(this));

        Object.getOwnPropertyNames(this.nodes).forEach(nodesKey => {
            var desc = this.nodes[nodesKey];
            if (desc.type === "Dataflow") {
                // FIXME update only connections whose endpoints changed
                this.updateConnection(desc);
            }
        });

        const mapById = arr => {
            return arr.reduce(function(map, obj) {
                map[obj.id] = obj;
                return map;
            }, {});
        };

        var connections = Object.getOwnPropertyNames(this.connections).map(connectionsKey => {
            var connection = this.connections[connectionsKey];
            var desc = connection.valueflows[0];
            var srcRect = this.nodes[getParentId(desc.srcId)];
            var dstRect = this.nodes[getParentId(desc.dstId)];
            if (!srcRect || !dstRect) {
                return;
            }
            var points;
            if (srcRect.top < dstRect.top) {
                var magic = 5; // FIXME: computed from Component border+padding+1
                points = `${srcRect.left + 100} ${srcRect.top + 31} ${dstRect.left + 50} ${srcRect.top + 31} ${dstRect.left + 50} ${dstRect.top - magic}`;
            } else {
                var magic = 5; // FIXME: computed from Component border+padding+1
                points = `${srcRect.left} ${srcRect.top + 31} ${dstRect.left + 50} ${srcRect.top + 31} ${dstRect.left + 50} ${dstRect.top + 62 + magic}`;
            }
            var ret = {};
            extend(ret, connection);
            ret.points = points;
            return ret;
        }).filter(connection => connection && connection.points);
        extend(this.app.state, {
            nodes: this.nodes,
            components: this.components,
            connections: mapById(connections),
            dispatchEvent: this.dispatchEvent
        });
        this.app.setState(this.app.state);
    };

    DataflowWidget.prototype.dispatchEvent = function (name, args) {
        // console.log(args);
        switch (name) {
            case 'inspect':
                this.app.state.inspector = args;
                this.app.setState(this.app.state);
        }
    };

    DataflowWidget.prototype.removeNode = function(gmeId) {
        var desc = this.nodes[gmeId];
        // this._el.append('<div>Removing node "' + desc.name + '"</div>');
        if (desc.connection) {
            var index = desc.connection.valueflows.indexOf(desc);
            desc.connection.valueflows.splice(index, 1);
            if (desc.connection.valueflows.length === 0) {
                delete this.connections[desc.connection.id];
            }
        }
        var componentIndex = this.components.indexOf(desc);
        if (componentIndex !== -1) {
            this.components.splice(componentIndex, 1);

        }
        delete this.nodes[gmeId];
    };

    DataflowWidget.prototype.updateConnection = function(desc) {
        if (desc.connection && (!desc.srcId || !desc.dstId)) {
            var index = desc.connection.valueflows.indexOf(desc);
            if (index === -1) {
                return;
            }
            desc.connection.valueflows.splice(index, 1);
            if (desc.connection.valueflows.length === 0) {
                delete this.connections[desc.connection.id];
            }
            delete desc.connection;
        }
        if (!desc.connection && (desc.srcId && desc.dstId)) {
            var connection = this.connections[getConnectionsKey(desc)];
            if (connection === undefined) {
                connection = this.connections[getConnectionsKey(desc)] = {
                    id: getConnectionsKey(desc),
                    valueflows: []
                };
            }
            this.nodes[desc.id].connection = connection;
            connection.valueflows.push(desc);
        }
    }

    // copy undefined values too (unlike JQuery)
    function extend(dst, src) {
        Object.getOwnPropertyNames(src).forEach(key => {
            dst[key] = src[key];
        });
    };

    DataflowWidget.prototype.updateNode = function(desc) {
        if (desc) {
            this._logger.debug('Updating node:', desc);
            extend(this.nodes[desc.id], desc);
            if (desc.type === "Dataflow") {
                // console.log(JSON.stringify(desc, (k, v) => { return  v === undefined ? null : v; }));
                this.updateConnection(this.nodes[desc.id]);
            }
            // this._el.append('<div>Updating node "' + desc.name + '"</div>');
        }
    };

    /* * * * * * * * Visualizer event handlers * * * * * * * */

    DataflowWidget.prototype.onNodeClick = function(/* id */) {
        // This currently changes the active node to the given id and
        // this is overridden in the controller.
    };

    DataflowWidget.prototype.onBackgroundDblClick = function() {
        // this._el.append('<div>Background was double-clicked!!</div>');
    };

    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    DataflowWidget.prototype.destroy = function() {};

    DataflowWidget.prototype.onActivate = function() {
        this._logger.debug('DataflowWidget has been activated');
    };

    DataflowWidget.prototype.onDeactivate = function() {
        this._logger.debug('DataflowWidget has been deactivated');
    };

    return DataflowWidget;
});
