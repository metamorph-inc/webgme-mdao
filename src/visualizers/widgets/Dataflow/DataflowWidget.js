/*globals define, WebGMEGlobal*/
/* jshint browser: true */

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Wed Jan 03 2018 13:04:07 GMT-0600 (Central Standard Time).
 */

import React from 'react';
import ReactDOM from 'react-dom';
import PropTypes from 'prop-types';
import {withStyles} from 'material-ui/styles';
import Table, {TableBody, TableCell, TableHead, TableRow} from 'material-ui/Table';
import Paper from 'material-ui/Paper';

define(['css!../../widgets/Dataflow/styles/DataflowWidget.css'], function () {
    'use strict';
    var COMPONENT_HEIGHT = 62;
    var COMPONENT_WIDTH = 100;

    class Component extends React.PureComponent {
        constructor() {
            super();
            this.handleClick = this.handleClick.bind(this);
            this.state = { img: true };
            this.hideImg = () => this.setState({...this.state, img: false});
            this.colorMap = {
                'Python': '#75b4f6',
                'Excel': '#cccccc', //'#00592d',
                'CATIA': '#cccccc',
                'PATRAN': '#cccccc',
                'NASTRAN': '#cccccc',
                'Matlab': '#f97a0f'
                };
            this.dragStart = (ev) => {
                return this.props.dragStart(ev, this.props.id);
            };
        }

        handleClick() {
            this.props.dispatchEvent('inspect', {
                id: this.props.id,
                type: 'Component'
            });
        }

        render() {
            var {
                name,
                top,
                left,
                wrapper,
                selected,
            } = this.props;
            const img = this.state.img;

            return <div
                draggable="true" onDragStart={this.dragStart}
                className={selected ? 'Component selected' : 'Component'}  style={{
                top: top + 'px',
                left: left + 'px',
                zIndex: 2,
                backgroundColor: this.colorMap[wrapper] || '#cccccc',
            }} onClick={this.handleClick}>
                { img ? <img src={`/extlib/images/${(wrapper || '').toLowerCase()}.png`} onError={this.hideImg} /> : null
		}
                {name}</div>
        }
    }

    class Connection extends React.PureComponent {
        constructor() {
            super();
            this.handleClick = this.handleClick.bind(this);
        }

        handleClick() {
            this.props.dispatchEvent('inspect', {
                id: this.props.id,
                type: 'Connection'
            });
        }

        render() {
            var {
                points,
                selected
            } = this.props;
            return <polyline xmlns="http://www.w3.org/2000/svg" points={points} markerEnd="url(#triangle)"
                             stroke={selected ? "red" : "black"} strokeWidth="2" fill="none" onClick={this.handleClick}/>
        }
    }

    // Visualization for a connection between two components
    class InspectorConnection extends React.Component {
        render() {
            const {
                id,
                nodes,
                connections,
            } = this.props;

            const valueflows = connections[id].valueflows;

            return (
                <Paper className={PropTypes.object.isRequired.root}>
                    <Table className={PropTypes.object.isRequired.table}>
                        <TableHead>
                            <TableRow>
                                <TableCell>Src Component</TableCell>
                                <TableCell>Src Variable</TableCell>
                                <TableCell>Dst Variable</TableCell>
                                <TableCell>Dst Component</TableCell>
                            </TableRow>
                        </TableHead>
                        <TableBody>
                            {(valueflows || []).map(vf => {
                                return (
                                    <TableRow key={vf.id}>
                                        <TableCell>{nodes[nodes[vf.srcId].parentId].name}</TableCell>
                                        <TableCell>{nodes[vf.srcId].name}</TableCell>
                                        <TableCell>{nodes[vf.dstId].name}</TableCell>
                                        <TableCell>{nodes[nodes[vf.dstId].parentId].name}</TableCell>
                                    </TableRow>
                                );
                            })}
                        </TableBody>
                    </Table>
                </Paper>
            );
        }
    }

    // Visualization for an individual Component
    class InspectorComponent extends React.Component {
        render() {
            const {
                nodes,
                id,
                connections,
                dispatchEvent,
            } = this.props;
            const selectComponent = (id) => {
                dispatchEvent('inspect', {
                    id: id,
                    type: 'Component'
                });
            };

            const name = nodes[id].name;

            var ports = [];
            nodes[id].childrenIds.forEach(port_id => {
                // How do we calculate what this guy is connected to?
                // We need to go through the 'connections' data structure
                //   and look for connections that have this as an end.
                // Then we can fetch details on the other end.
                var other_sides = [];
                Object.keys(connections).forEach(key => {
                    connections[key].valueflows.forEach(vf => {
                        var srcId = vf.srcId,
                            dstId = vf.dstId

                        if (vf.srcId == port_id) {
                            // Let's learn about the destination.
                            other_sides.push({
                                componentId: nodes[nodes[vf.dstId].parentId].id,
                                componentName: nodes[nodes[vf.dstId].parentId].name,
                                name: nodes[vf.dstId].name
                            });
                        }
                        else if (vf.dstId == port_id) {
                            // Let's learn about the source.
                            other_sides.push({
                                componentId: nodes[nodes[vf.srcId].parentId].id,
                                componentName: nodes[nodes[vf.srcId].parentId].name,
                                name: nodes[vf.srcId].name
                            });
                        }
                    });
                });

                var other_sides_str =
                other_sides.map((os, i) => {
                    return (<span key={i} onClick={_ => selectComponent(os.componentId)}>{os.componentName}::{os.name}</span>);
                });

                var port_data = nodes[port_id];
                ports.push({
                    name: port_data.name,
                    type: port_data.type,
                    id: port_data.id,
                    typeAttribute: port_data.typeAttribute,
                    connectedTo: other_sides_str
                });
            });
            ports.sort((a, b) => {
                const inOut = a.type.localeCompare(b.type);
                if (inOut !== 0) {
                    return inOut;
                }
                return a.name.localeCompare(b.name);
            });
            if (ports.length === 0) {
                return ( <div style={{fontStyle: 'italic', backgroundColor: '#FFF', padding: '40px', height: '100%', textAlign: 'center', borderTop: '2px solid #cccccc', color: '#999'}}>No inputs or outputs</div>) ;
            }

            return (
                <Paper className={PropTypes.object.isRequired.root}>
                    <Table className={PropTypes.object.isRequired.table}>
                        <TableHead>
                            <TableRow>
                                <TableCell>Component</TableCell>
                                <TableCell>Variable</TableCell>
                                <TableCell>Input/Output</TableCell>
                                <TableCell>Type</TableCell>
                                <TableCell>Connected To</TableCell>
                            </TableRow>
                        </TableHead>
                        <TableBody>
                            {ports.map(p => {
                                return (
                                    <TableRow key={p.id}>
                                        <TableCell>{name}</TableCell>
                                        <TableCell>{p.name}</TableCell>
                                        <TableCell>{p.type}</TableCell>
                                        <TableCell>{p.typeAttribute}</TableCell>
                                        <TableCell>{p.connectedTo}</TableCell>
                                    </TableRow>
                                );
                            })}
                        </TableBody>
                    </Table>
                </Paper>
            )
        }
    }

    class Inspector extends React.Component {
        render() {
            var {
                type,
            } = this.props;
            const props = this.props;
            switch (type) {
                case 'Connection':
                    return (<InspectorConnection {...props}/>)
                case 'Component':
                    return (<InspectorComponent {...props}/>);
                default:
                    return <div style={{backgroundColor: '#eee', height: '100%'}}/>;
            }
        }
    }

    class App extends React.Component {
        constructor() {
            super();
            this.state = {
                components: [
                    // { id: '/a/b/c', top: 100, left: 400, name: 'tst'}
                ],
                connections: [],
                dispatchEvent: () => {
                },
                inspectorHeight: 220,
                inspector: {},
                nodes: {},
                connections: {},
            };
            this.dragOver = (ev) => {
                 ev.preventDefault();
                 ev.dataTransfer.dropEffect = "move";
                 var comp = this.state.components.filter((c) => { return c.id === this.dragComponentId })[0];
                 if (!this.dragComponentId || !comp) {
                   return;
                 }
                 var index = this.state.components.indexOf(comp);

                 var rect = this.componentsDiv.getBoundingClientRect();
                 // console.log(`${ev.pageX}  - ${rect.left} (${ev.pageX - rect.left}) > ${comp.left} + 101`);
                 if (ev.pageX - rect.left > comp.left + COMPONENT_WIDTH * 1.2 &&
                     ev.pageY - rect.top > comp.top + COMPONENT_WIDTH * 1.2) {
                       if (index === this.state.components.length - 1) {
                         return;
                       }
                       this.state.dispatchEvent('moveComponent', [this.dragComponentId, 1]);
                 }
                 else if (ev.pageX - rect.left < comp.left - COMPONENT_WIDTH * 0.2 &&
                     ev.pageY - rect.top < comp.top - COMPONENT_WIDTH * 0.2) {
                       if (index === 0) {
                         return;
                       }
                     this.state.dispatchEvent('moveComponent', [this.dragComponentId, -1]);
                 }
             };
             this.dragStart = (ev, componentId) => {
                 ev.dataTransfer.dropEffect = "move";
                 this.dragComponentId = componentId;
             };
         }

        render() {
            const {
                nodes,
                components,
                connections,
                dispatchEvent,
                width,
                height,
                inspectorHeight,
                inspector
            } = this.state;

            const componentsHeight = components.map(c => {
                return c.top
            }).reduce((a, b) => {
                return Math.max(a, b)
            }, 0);

            // <div style={{width: '100%', height: components.map(c => { return c.top }).reduce((a, b) => { return Math.max(a,b) }, 0) + 200 + 'px' }}>
            // <div style={{width: '100%', height: 'calc(100% - 3em)'}}>
            return (<div style={{
                width,
                height
            }}>

                <div style={{
                    width: '100%',
                    height: `calc(100% - ${inspectorHeight}px)`,
                    overflow: 'auto'
                }}>
                    <div style={{
                        width: '100%',
                        height: componentsHeight + 150 + 'px',
                        position: 'relative'
                    }}
                    onDragOver={this.dragOver}
                    ref={(div) => { this.componentsDiv = div; }}
                    >
                        {
                            components.map(c => {
                                return <Component key={c.id} id={c.id} top={c.top} left={c.left} name={c.name}
                                                  wrapper={c.wrapper} dispatchEvent={dispatchEvent} selected={inspector.id === c.id} dragStart={this.dragStart}/>;
                            })
                        }
                        <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" style={{
                            position: "absolute",
                            overflow: "unset"
                        }}>
                            <marker xmlns="http://www.w3.org/2000/svg" id="triangle" viewBox="0 0 10 10" refX="0"
                                    refY="5" markerUnits="strokeWidth" markerWidth="4" markerHeight="3" orient="auto">
                                <path d="M 0 0 L 10 5 L 0 10 z"/>
                            </marker>
                            {
                                Object.getOwnPropertyNames(connections).map(id => {
                                    const c = connections[id];
                                    return (<Connection key={c.id} id={c.id} points={c.points}
                                                        dispatchEvent={dispatchEvent} selected={inspector.id === c.id}/>)
                                })
                            }
                        </svg>
                    </div>
                </div>
                <div style={{
                    width: '100%',
                    height: inspectorHeight + 'px',
                    top: `calc(100% - ${inspectorHeight}px)`,
                    position: 'absolute',
                }}><Inspector id={inspector.id} type={inspector.type} components={components} connections={connections}
                              nodes={nodes} dispatchEvent={dispatchEvent}/></div>
            </div>);
        }
    }

    var DataflowWidget,
        WIDGET_CLASS = 'dataflow';

    DataflowWidget = function DataflowWidget(logger, container) {
        this._logger = logger.fork('Widget');

        this._el = container;

        this.nodes = {};
        this._initialize();

        this.components = [];
        this.connections = {};
        this.newConnections = [];
        this.dispatchEvent = this.dispatchEvent.bind(this);
        this._logger.debug('ctor finished');
    };

    DataflowWidget.prototype._initialize = function () {
        // set widget class
        this._el.addClass(WIDGET_CLASS);

        this.app = ReactDOM.render(<App/>, this._el.get(0));

        // Create a dummy header
        // this._el.append('<h3>Dataflow Events:</h3>');

        // Registering to events can be done with jQuery (as normal)
        /*this._el.on('dblclick', event => {
            event.stopPropagation();
            event.preventDefault();
            this.onBackgroundDblClick();
        }); */
    };

    DataflowWidget.prototype.onWidgetContainerResize = function (width, height) {
        this._logger.debug('Widget is resizing...');

        this.app.setState({
            ...this.app.state,
            width,
            height
        });
    };

    DataflowWidget.prototype.render = function () {
    };

    // Adding/Removing/Updating items
    DataflowWidget.prototype.addNode = function (desc) {
        this.nodes[desc.id] = desc;

        if (desc && desc.type === 'Component') {
            this.components.push(desc);
        } else if (desc && desc.type === 'Dataflow') {
            this.newConnections.push(desc);
        }
    };

    function getParentId(id) {
        return id.substr(0, id.lastIndexOf('/'));
    };

    function getConnectionsKey(connection) {
        var strip = getParentId;
        return strip(connection.srcId) + '__' + strip(connection.dstId);
    };

    DataflowWidget.prototype.territoryComplete = function () {
        var counter = 0;
        this.components.sort((a, b) => {
            var comp = (a.position || 0) - (b.position || 0);
            if (comp !== 0) {
              return comp;
            }
            return a.name.localeCompare(b.name);
        });
        this.components.forEach(component => {
            component.top = 80 + counter * COMPONENT_WIDTH;
            component.left = 80 + counter * COMPONENT_WIDTH;
            counter++;
        });

        var newConnections = this.newConnections;
        this.newConnections = [];
        newConnections.forEach(this.updateConnection.bind(this));

        Object.getOwnPropertyNames(this.nodes).forEach(nodesKey => {
            var desc = this.nodes[nodesKey];
            if (desc.type === "Dataflow") {
                // FIXME update only connections whose endpoints changed
                this.updateConnection(desc);
            }
        });

        const mapById = arr => {
            return arr.reduce(function (map, obj) {
                map[obj.id] = obj;
                return map;
            }, {});
        };

        this.recalculateConnectionPoints();
        const state = {
            ...this.app.state,
            nodes: this.nodes,
            components: this.components,
            connections: this.connections,
            dispatchEvent: this.dispatchEvent,
        };
        this.app.setState(state);

        var endTx = () => {};
        var startTx = () => {
          this.client.startTransaction('Set Workflow positions ');
          startTx = () => {};
          endTx = () => {
            this.client.completeTransaction('', (err, result) => {
              if (err) {
                console.log(err);
              }
            });
          };
        };
        setTimeout(() => {
          this.components.reduce((pos, component) => {
            if (component.position !== pos) {
              startTx();
              component.position = pos;
              this.client.setRegistry(component.id, 'dataflow_position', pos, 'set position');
              // console.log(`init ${component.name} ${component.position}`);
            }
            return pos + 1;
          }, 0);
          endTx();
        }, 1);
    };

    DataflowWidget.prototype.recalculateConnectionPoints = function() {
      Object.getOwnPropertyNames(this.connections).forEach(connectionsKey => {
          var connection = this.connections[connectionsKey];
          var desc = connection.valueflows[0];
          var srcRect = this.nodes[getParentId(desc.srcId)];
          var dstRect = this.nodes[getParentId(desc.dstId)];
          if (!srcRect || !dstRect) {
              debugger;
              return;
          }
          var points;
          var COMPONENT_WIDTH_2 = COMPONENT_WIDTH / 2;
          var COMPONENT_HEIGHT_2 = COMPONENT_HEIGHT / 2;
          var dstIndex = this.components.indexOf(this.nodes[connection.dstId]);
          var srcIndex = this.components.indexOf(this.nodes[connection.srcId]);
          var nComponents = this.components.length;
          if (srcRect.top < dstRect.top) {
              var magic = 5; // FIXME: computed from Component border+padding+1
              const y1 = Math.floor(srcRect.top + COMPONENT_HEIGHT * 3 / 4 - COMPONENT_HEIGHT_2 * dstIndex / nComponents);
              const x2 = Math.floor(dstRect.left + COMPONENT_WIDTH * 1 / 4 + COMPONENT_WIDTH_2 * srcIndex / nComponents);
              points = `${srcRect.left + COMPONENT_WIDTH} ${y1} ${x2} ${y1} ${x2} ${dstRect.top - magic}`;
          } else {
              var magic = 5; // FIXME: computed from Component border+padding+1
              const y1 = Math.floor(srcRect.top + COMPONENT_HEIGHT * 3 / 4 - COMPONENT_HEIGHT_2 * dstIndex / nComponents);
              const x2 = Math.floor(dstRect.left + COMPONENT_WIDTH * 3 / 4 - COMPONENT_WIDTH_2 * srcIndex / nComponents);
              points = `${srcRect.left} ${y1} ${x2} ${y1} ${x2} ${dstRect.top + COMPONENT_HEIGHT + magic}`;
          }
          connection.points = points;
      });
    }


    DataflowWidget.prototype.dispatchEvent = function (name, args) {
        // console.log(args);
        switch (name) {
            case 'inspect':
                this.app.setState({
                    ...this.app.state,
                    inspector: args
                });
            case 'moveComponent':
                var componentId = args[0];
                var direction = args[1];
                var comps = this.components = this.components.slice();
                var comp = comps.filter((c) => { return c.id === componentId })[0];
                var index = comps.indexOf(comp);

                if (direction === 1) {
                  comps.splice(index, 1);
                  comps.splice(index + 1, 0, comp);
                }
                else if (direction === -1) {
                  comps.splice(index, 1);
                  comps.splice(index - 1, 0, comp);
                }
                var left = comp.left;
                var top = comp.top;
                comp.left = comps[index].left;
                comp.top = comps[index].top;
                comps[index].left = left;
                comps[index].top = top;
                comp.position = index + direction;
                comps[index].position = index;
                this.client.startTransaction('Set Workflow positions ');
                this.client.setRegistry(comp.id, 'dataflow_position', comp.position, 'set position');
                this.client.setRegistry(comps[index].id, 'dataflow_position', comps[index].position, 'set position');
                // console.log(`${comp.name}   ${comp.position}`);
                // console.log(`${comps[index].name}   ${comps[index].position}`);
                this.client.completeTransaction('', (err, result) => {
                  if (err) {
                    console.log(err);
                  }
                });

                this.recalculateConnectionPoints();
                this.app.setState({...this.app.state,
                     components: this.components,
                     connections: this.connections});

        }
    };

    DataflowWidget.prototype.removeNode = function (gmeId) {
        var desc = this.nodes[gmeId];
        // this._el.append('<div>Removing node "' + desc.name + '"</div>');
        if (desc.connection) {
            var index = desc.connection.valueflows.indexOf(desc);
            desc.connection.valueflows.splice(index, 1);
            if (desc.connection.valueflows.length === 0) {
                delete this.connections[desc.connection.id];
            }
            if (this.app.state.inspector.id === desc.connection.id) {
                this.app.setState({...this.app.state,
                    inspector: {id: null, type: null}
                });
            }
        }
        var componentIndex = this.components.indexOf(desc);
        if (componentIndex !== -1) {
            this.components.splice(componentIndex, 1);
            if (this.app.state.inspector.id === desc.id) {
                this.app.setState({...this.app.state,
                    inspector: {id: null, type: null}
                });
            }
        }

        delete this.nodes[gmeId];
    };

    DataflowWidget.prototype.updateConnection = function (desc) {
        if (desc.connection && (!desc.srcId || !desc.dstId)) {
            var index = desc.connection.valueflows.indexOf(desc);
            if (index === -1) {
                return;
            }
            desc.connection.valueflows.splice(index, 1);
            if (desc.connection.valueflows.length === 0) {
                delete this.connections[desc.connection.id];
            }
            if (this.app.state.inspector.id === desc.connection.id) {
                this.app.setState({...this.app.state,
                    inspector: {id: null, type: null}
                });
            }

            delete desc.connection;
        }
        if (!desc.connection && (desc.srcId && desc.dstId)) {
            var connection = this.connections[getConnectionsKey(desc)];
            if (connection === undefined) {
                connection = this.connections[getConnectionsKey(desc)] = {
                    id: getConnectionsKey(desc),
                    valueflows: [],
                    srcId: getParentId(desc.srcId),
                    dstId: getParentId(desc.dstId),
                };
            }
            this.nodes[desc.id].connection = connection;
            connection.valueflows.push(desc);
        }
    }

    // copy undefined values too (unlike JQuery)
    function extend(dst, src) {
        Object.getOwnPropertyNames(src).forEach(key => {
            dst[key] = src[key];
        });
    };

    DataflowWidget.prototype.updateNode = function (desc) {
        if (desc) {
            this._logger.debug('Updating node:', desc);
            extend(this.nodes[desc.id], desc);
            if (desc.type === "Dataflow") {
                // console.log(JSON.stringify(desc, (k, v) => { return  v === undefined ? null : v; }));
                this.updateConnection(this.nodes[desc.id]);
            }
            // this._el.append('<div>Updating node "' + desc.name + '"</div>');
        }
    };

    /* * * * * * * * Visualizer event handlers * * * * * * * */

    DataflowWidget.prototype.onNodeClick = function (/* id */) {
        // This currently changes the active node to the given id and
        // this is overridden in the controller.
    };

    DataflowWidget.prototype.onBackgroundDblClick = function () {
        // this._el.append('<div>Background was double-clicked!!</div>');
    };

    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    DataflowWidget.prototype.destroy = function () {
    };

    DataflowWidget.prototype.onActivate = function () {
        this._logger.debug('DataflowWidget has been activated');
    };

    DataflowWidget.prototype.onDeactivate = function () {
        this._logger.debug('DataflowWidget has been deactivated');
    };

    return DataflowWidget;
});
