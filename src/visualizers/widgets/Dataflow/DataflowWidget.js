/*globals define, WebGMEGlobal*/
/* jshint browser: true */

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Wed Jan 03 2018 13:04:07 GMT-0600 (Central Standard Time).
 */

import React from 'react';
import ReactDOM from 'react-dom';
import PropTypes from 'prop-types';
import { withStyles } from 'material-ui/styles';
import Table, { TableBody, TableCell, TableHead, TableRow } from 'material-ui/Table';
import Paper from 'material-ui/Paper';

define(['css!../../widgets/Dataflow/styles/DataflowWidget.css'], function() {
    'use strict';

    class Component extends React.PureComponent {
        constructor() {
            super();
            this.handleClick = this.handleClick.bind(this);
        }

        handleClick() {
            this.props.dispatchEvent('inspect', {
                id: this.props.id,
                type: 'Component'
            });
        }

        render() {
            var {
                name,
                top,
                left
            } = this.props;

            return <div className='Component' style={{
                    top: top + 'px',
                    left: left + 'px',
                    zIndex: 2
                }} onClick={this.handleClick}>
                {name}</div>
        }
    }

    class Connection extends React.PureComponent {
        constructor() {
            super();
            this.handleClick = this.handleClick.bind(this);
        }

        handleClick() {
            this.props.dispatchEvent('inspect', {
                id: this.props.id,
                type: 'Connection'
            });
        }

        render() {
            var {
                points
            } = this.props;
            return <polyline xmlns="http://www.w3.org/2000/svg" points={points} markerEnd="url(#triangle)" stroke="black" strokeWidth="2" fill="none" onClick={this.handleClick}/>
        }
    }

    // Visualization for a connection between two components
    class InspectorConnection extends React.Component {
        render() {
            const {
                id,
                nodes,
                connections,
            } = this.props;
            const valueflows = connections[id].valueflows;
            return (<div>{ (valueflows || []).map(vf => {
                var srcPort = nodes[vf.srcId];
                var dstPort = nodes[vf.dstId];
                var src = srcPort ? nodes[srcPort.parentId] : undefined;
                var dst = dstPort ? nodes[dstPort.parentId] : undefined;
                return <div key={vf.id}>{src.name}.{srcPort.name} {dst.name}.{dstPort.name}</div>; })
            }</div>);
        }
    }

    // Visualization for an individual Component
    class InspectorComponent extends React.Component {
        render() {
            const {
                nodes,
                id,
                connections,
            } = this.props;

            const name = nodes[id].name;

            var ports = [];
            nodes[id].childrenIds.forEach(port_id => {
                // How do we calculate what this guy is connected to?
                // We need to go through the 'connections' data structure
                //   and look for connections that have this as an end.
                // Then we can fetch details on the other end.
                var other_sides = [];
                Object.keys(connections).forEach(key => {
                    connections[key].valueflows.forEach(vf => {
                        var srcId = vf.srcId,
                            dstId = vf.dstId

                        if (vf.srcId == port_id) {
                            // Let's learn about the destination.
                            other_sides.push({
                                componentName: nodes[nodes[vf.dstId].parentId].name,
                                name: nodes[vf.dstId].name
                            });
                        }
                        else if (vf.dstId == port_id) {
                            // Let's learn about the source.
                            other_sides.push({
                                componentName: nodes[nodes[vf.srcId].parentId].name,
                                name: nodes[vf.srcId].name
                            });
                        }
                    });
                });

                var other_sides_str = [];
                other_sides.forEach(os => {
                    other_sides_str.push(os.componentName + "::" + os.name);
                });

                var port_data = nodes[port_id];
                ports.push({
                    name: port_data.name,
                    type: port_data.type,
                    id: port_data.id,
                    // datatype: port_data.datatype
                    connectedTo: other_sides_str.join(', ')
                });
            });

            return (
                <Paper className={PropTypes.object.isRequired.root}>
                    <Table className={PropTypes.object.isRequired.table}>
                        <TableHead>
                            <TableRow>
                                <TableCell>Component</TableCell>
                                <TableCell>Variable</TableCell>
                                <TableCell>Input/Output</TableCell>
                                <TableCell>Type</TableCell>
                                <TableCell>Connected To</TableCell>
                            </TableRow>
                        </TableHead>
                        <TableBody>
                            {ports.map( p => {
                                return (
                                    <TableRow key={p.id}>
                                        <TableCell>{name}</TableCell>
                                        <TableCell>{p.name}</TableCell>
                                        <TableCell>{p.type}</TableCell>
                                        <TableCell>{p.datatype}</TableCell>
                                        <TableCell>{p.connectedTo}</TableCell>
                                    </TableRow>
                                );
                            })}
                        </TableBody>
                    </Table>
                </Paper>
            )

            // return <div>{name}</div>;
        }
    }

    class Inspector extends React.Component {
        render() {
            var {
                type,
            } = this.props;
            const props = this.props;
            switch (type) {
                case 'Connection':
                    return (<InspectorConnection {...props}/>)
                case 'Component':
                    return (<InspectorComponent {...props}/>);
                default:
                    return <div/>;
            }
        }
    }

    class App extends React.Component {
        constructor() {
            super();
            this.state = {
                components: [
                    // { id: '/a/b/c', top: 100, left: 400, name: 'tst'}
                ],
                connections: [],
                dispatchEvent: () => {},
                inspectorHeight: 250,
                inspector: {},
                nodes: {},
                connections: {}
            };
        }

        render() {
            const {
                nodes,
                components,
                connections,
                dispatchEvent,
                width,
                height,
                inspectorHeight,
                inspector
            } = this.state;

            const componentsHeight = components.map(c => {
                return c.top
            }).reduce((a, b) => {
                return Math.max(a, b)
            }, 0);

            // <div style={{width: '100%', height: components.map(c => { return c.top }).reduce((a, b) => { return Math.max(a,b) }, 0) + 200 + 'px' }}>
            // <div style={{width: '100%', height: 'calc(100% - 3em)'}}>
            return (<div style={{
                    width,
                    height
                }}>

                <div style={{
                        width: '100%',
                        height: `calc(100% - ${inspectorHeight}px)`,
                        overflow: 'auto'
                    }}>
                    <div style={{
                            width: '100%',
                            height: componentsHeight + 150 + 'px',
                            position: 'relative'
                        }}>
                        {
                            components.map(function(c) {
                                return <Component key={c.id} id={c.id} top={c.top} left={c.left} name={c.name} dispatchEvent={dispatchEvent}/>;
                            })
                        }
                        <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" style={{
                                position: "absolute",
                                overflow: "unset"
                            }}>
                            <marker xmlns="http://www.w3.org/2000/svg" id="triangle" viewBox="0 0 10 10" refX="0" refY="5" markerUnits="strokeWidth" markerWidth="4" markerHeight="3" orient="auto">
                                <path d="M 0 0 L 10 5 L 0 10 z"/>
                            </marker>
                            {
                                Object.getOwnPropertyNames(connections).map(id => {
                                    const c = connections[id];
                                    return (<Connection key={c.id} id={c.id} points={c.points} dispatchEvent={dispatchEvent}/>)
                                })
                            }
                        </svg>
                    </div>
                </div>
                <div style={{
                        width: '100%',
                        height: inspectorHeight + 'px',
                        top: `calc(100% - ${inspectorHeight}px)`,
                        position: 'absolute',
                        backgroundColor: 'lightgrey'
                    }}><Inspector id={inspector.id} type={inspector.type} components={components} connections={connections} nodes={nodes}/></div>
            </div>);
        }
    }

    var DataflowWidget,
        WIDGET_CLASS = 'dataflow';

    DataflowWidget = function DataflowWidget(logger, container) {
        this._logger = logger.fork('Widget');

        this._el = container;

        this.nodes = {};
        this._initialize();

        this.components = [];
        this.connections = {};
        this.newConnections = [];
        this.dispatchEvent = this.dispatchEvent.bind(this);
        this._logger.debug('ctor finished');
    };

    DataflowWidget.prototype._initialize = function() {
        // set widget class
        this._el.addClass(WIDGET_CLASS);

        this.app = ReactDOM.render(<App/>, this._el.get(0));

        // Create a dummy header
        // this._el.append('<h3>Dataflow Events:</h3>');

        // Registering to events can be done with jQuery (as normal)
        /*this._el.on('dblclick', event => {
            event.stopPropagation();
            event.preventDefault();
            this.onBackgroundDblClick();
        }); */
    };

    DataflowWidget.prototype.onWidgetContainerResize = function(width, height) {
        this._logger.debug('Widget is resizing...');

        this.app.setState({
          ...this.app.state,
          width,
          height});
    };

    DataflowWidget.prototype.render = function() {};

    // Adding/Removing/Updating items
    DataflowWidget.prototype.addNode = function(desc) {
        this.nodes[desc.id] = desc;

        if (desc && desc.type === 'Component') {
            this.components.push(desc);
        } else if (desc && desc.type === 'Dataflow') {
            this.newConnections.push(desc);
        }
    };

    function getParentId(id) {
        return id.substr(0, id.lastIndexOf('/'));
    };

    function getConnectionsKey(connection) {
        var strip = getParentId;
        return strip(connection.srcId) + '__' + strip(connection.dstId);
    };

    DataflowWidget.prototype.territoryComplete = function() {
        var counter = 0;
        this.components.sort((a, b) => {
            if (a.name < b.name) {
                return -1;
            }
            if (a.name > b.name) {
                return 1;
            }
            return 0;
        });
        this.components.forEach(component => {
            component.top = 80 + counter * 100;
            component.left = 80 + counter * 100;
            counter++;
        });

        var newConnections = this.newConnections;
        this.newConnections = [];
        newConnections.forEach(this.updateConnection.bind(this));

        Object.getOwnPropertyNames(this.nodes).forEach(nodesKey => {
            var desc = this.nodes[nodesKey];
            if (desc.type === "Dataflow") {
                // FIXME update only connections whose endpoints changed
                this.updateConnection(desc);
            }
        });

        const mapById = arr => {
            return arr.reduce(function(map, obj) {
                map[obj.id] = obj;
                return map;
            }, {});
        };

        var connections = Object.getOwnPropertyNames(this.connections).map(connectionsKey => {
            var connection = this.connections[connectionsKey];
            var desc = connection.valueflows[0];
            var srcRect = this.nodes[getParentId(desc.srcId)];
            var dstRect = this.nodes[getParentId(desc.dstId)];
            if (!srcRect || !dstRect) {
                debugger;
                return;
            }
            var points;
            if (srcRect.top < dstRect.top) {
                var magic = 5; // FIXME: computed from Component border+padding+1
                points = `${srcRect.left + 100} ${srcRect.top + 31} ${dstRect.left + 50} ${srcRect.top + 31} ${dstRect.left + 50} ${dstRect.top - magic}`;
            } else {
                var magic = 5; // FIXME: computed from Component border+padding+1
                points = `${srcRect.left} ${srcRect.top + 31} ${dstRect.left + 50} ${srcRect.top + 31} ${dstRect.left + 50} ${dstRect.top + 62 + magic}`;
            }
            connection.points = points;
        });
        const state = {... this.app.state,
            nodes: this.nodes,
            components: this.components,
            connections: this.connections,
            dispatchEvent: this.dispatchEvent
        };
        this.app.setState(state);
    };

    DataflowWidget.prototype.dispatchEvent = function (name, args) {
        // console.log(args);
        switch (name) {
            case 'inspect':
                this.app.setState({
                  ...this.app.state,
                  inspector: args});
        }
    };

    DataflowWidget.prototype.removeNode = function(gmeId) {
        var desc = this.nodes[gmeId];
        // this._el.append('<div>Removing node "' + desc.name + '"</div>');
        if (desc.connection) {
            var index = desc.connection.valueflows.indexOf(desc);
            desc.connection.valueflows.splice(index, 1);
            if (desc.connection.valueflows.length === 0) {
                delete this.connections[desc.connection.id];
            }
        }
        var componentIndex = this.components.indexOf(desc);
        if (componentIndex !== -1) {
            this.components.splice(componentIndex, 1);

        }
        delete this.nodes[gmeId];
    };

    DataflowWidget.prototype.updateConnection = function(desc) {
        if (desc.connection && (!desc.srcId || !desc.dstId)) {
            var index = desc.connection.valueflows.indexOf(desc);
            if (index === -1) {
                return;
            }
            desc.connection.valueflows.splice(index, 1);
            if (desc.connection.valueflows.length === 0) {
                delete this.connections[desc.connection.id];
            }
            delete desc.connection;
        }
        if (!desc.connection && (desc.srcId && desc.dstId)) {
            var connection = this.connections[getConnectionsKey(desc)];
            if (connection === undefined) {
                connection = this.connections[getConnectionsKey(desc)] = {
                    id: getConnectionsKey(desc),
                    valueflows: []
                };
            }
            this.nodes[desc.id].connection = connection;
            connection.valueflows.push(desc);
        }
    }

    // copy undefined values too (unlike JQuery)
    function extend(dst, src) {
        Object.getOwnPropertyNames(src).forEach(key => {
            dst[key] = src[key];
        });
    };

    DataflowWidget.prototype.updateNode = function(desc) {
        if (desc) {
            this._logger.debug('Updating node:', desc);
            extend(this.nodes[desc.id], desc);
            if (desc.type === "Dataflow") {
                // console.log(JSON.stringify(desc, (k, v) => { return  v === undefined ? null : v; }));
                this.updateConnection(this.nodes[desc.id]);
            }
            // this._el.append('<div>Updating node "' + desc.name + '"</div>');
        }
    };

    /* * * * * * * * Visualizer event handlers * * * * * * * */

    DataflowWidget.prototype.onNodeClick = function(/* id */) {
        // This currently changes the active node to the given id and
        // this is overridden in the controller.
    };

    DataflowWidget.prototype.onBackgroundDblClick = function() {
        // this._el.append('<div>Background was double-clicked!!</div>');
    };

    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    DataflowWidget.prototype.destroy = function() {};

    DataflowWidget.prototype.onActivate = function() {
        this._logger.debug('DataflowWidget has been activated');
    };

    DataflowWidget.prototype.onDeactivate = function() {
        this._logger.debug('DataflowWidget has been deactivated');
    };

    return DataflowWidget;
});
